Question: You are given a number n and an array, l of size k. Find the longest partition of n using the numbers from the array.

My comments: Spent a lot of time on this

Method I - Brute Force (Tutorial)

  The original question had k = 3 and n<4000
  One had to maximize x+y+z where ax + by + cz = n
  One could brute force through all combinations of x and y and find z using the second equation while maximizing x+y+z
  CHEAP!!!!

Method II - DP(Top - down)
  This method is messed up atm(or I feel messed up about it right now). Read the code to understand it

Method III - DP(Bottom - up)
  A very legit method.
  First initialize a dp array of size n+1 to 0.
  You start off with 0, and keep building the ribbon of length n by keep iterating through l
  A ribbon of length i could be made from either one of i-l[j] where j =0 to k-1.
  So, you take the max count by iterating through j.
  dp[i] = max(dp[i],dp[i-l[j]]+1)
  In the end, dp[n] will be the count of the max number of pieces.

  Time Complexity: O(n*k)
    Every element is looked up k times, where each look up takes constant time.

  Space Complexity: O(n)


  The Code(from the tutorial):

    #include<iostream>
    #include<algorithm>
    #include<cstring>
    #include<vector>
    #include<cmath>

    using namespace std;
    int arr[3], dp[4100];

    int main()
    {
        ios::sync_with_stdio(0);
        int n, a, b, c;
        cin>>n>>arr[0]>>arr[1]>>arr[2];

        memset(dp, -510000, sizeof(dp));
        dp[0] = 0;

        for(int i = 1; i <= n; i++)
        {
            for(int j = 0; j < 3; j++)
            {
                int val = i - arr[j];
                if(val >= 0)
                    dp[i] = max(dp[i], dp[i - arr[j]] + 1);
            }
        }

        cout<<dp[n];
        return 0;
    }
